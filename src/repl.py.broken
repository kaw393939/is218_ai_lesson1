"""REPL (Read-Eval-Print Loop) for calculator application    def __init__(self, config: CalculatorConfig | None = None):  # pylint: disable=super-init-not-called
        """Initialize the calculator REPL.

        Args:
            config: Optional configuration object. If None, creates default config.
        """
        self.running = False
        self.config = config or CalculatorConfig()

        # Setup logging
        setup_logging(
            level=self.config.log_level,
            log_file=self.config.log_file
        )
        self.logger = get_logger(__name__)

        # Session tracking
        self.session_id = str(uuid.uuid4())[:8]
        self.operation_count = 0

        self.logger.info(
            "Calculator session started",
            extra={'session_id': self.session_id}
        )port uuid
from config import TypedConfig
from logger import get_logger, setup_logging


class CalculatorConfig(TypedConfig):
    """Configuration for calculator REPL with sensible defaults."""

    def __init__(self):  # pylint: disable=super-init-not-called
        """Initialize calculator configuration.

        Note: We override parent __init__ because we don't need API_KEY
        for the calculator. We only inherit the helper methods.
        """
        # Don't call super().__init__() because TypedConfig requires API_KEY

    @property
    def precision(self) -> int:
        """Number of decimal places to display."""
        return self.get_int('REPL_PRECISION', 2)

    @property
    def max_value(self) -> float:
        """Maximum allowed value for operations."""
        return self.get_float('REPL_MAX_VALUE', 1000000.0)

    @property
    def welcome_message(self) -> str:
        """Welcome message shown on startup."""
        return self.get_str('REPL_WELCOME_MESSAGE', 'Calculator REPL v1.0')

    @property
    def show_help(self) -> bool:
        """Whether to show help on startup."""
        return self.get_bool('REPL_SHOW_HELP', True)

    @property
    def log_level(self) -> str:
        """Logging level (DEBUG, INFO, WARNING, ERROR)."""
        return self.get_str('REPL_LOG_LEVEL', 'INFO')

    @property
    def log_file(self) -> str:
        """Path to log file."""
        return self.get_str('REPL_LOG_FILE', 'calculator.log')

    @property
    def log_to_console(self) -> bool:
        """Whether to show logs in console."""
        return self.get_bool('REPL_LOG_TO_CONSOLE', False)


class CalculatorREPL:
    """Interactive calculator REPL."""

    def __init__(self, config: CalculatorConfig | None = None):
        """Initialize the calculator REPL.

        Args:
            config: Optional configuration object. If None, creates default config.
        """
        self.running = False
        self.config = config or CalculatorConfig()

        # Setup logging
        setup_logging(
            level=self.config.log_level,
            log_file=self.config.log_file
        )
        self.logger = get_logger(__name__)

        # Session tracking
        self.session_id = str(uuid.uuid4())[:8]
        self.operation_count = 0

        self.logger.info(
            "Calculator session started",
            extra={'session_id': self.session_id}
        )

    def start(self):
        """Start the REPL."""
        self.running = True
        print(self.config.welcome_message)
        if self.config.show_help:
            self._print_help()
        print()

        while self.running:
            try:
                user_input = input("> ")
                self.process_command(user_input)
            except KeyboardInterrupt:
                # Handle Ctrl+C gracefully
                print("\nUse 'exit' to quit")
            except EOFError:
                # Handle Ctrl+D gracefully
                print("\nGoodbye!")
                break

    def _print_help(self):
        """Print available commands and current settings."""
        print("\nAvailable commands:")
        print("  add <num1> <num2>      - Add two numbers")
        print("  subtract <num1> <num2> - Subtract num2 from num1")
        print("  multiply <num1> <num2> - Multiply two numbers")
        print("  divide <num1> <num2>   - Divide num1 by num2")
        print("  help                   - Show this help message")
        print("  exit                   - Exit the calculator")
        print(f"\nPrecision: {self.config.precision} decimal places")
        print(f"Max value: {self.config.max_value}")

    def process_command(self, user_input: str):
        """Process a user command.

        Args:
            user_input: Raw input from user
        """
        # Strip whitespace and split into parts
        parts = user_input.strip().split()

        if not parts:
            return

        command = parts[0].lower()
        args = parts[1:]

        # Handle exit
        if command == 'exit':
            print("Goodbye!")
            self.running = False
            return

        # Handle help
        if command == 'help':
            self._print_help()
            return

        # Execute command
        try:
            result = self.execute_command(command, args)
            print(f"Result: {result}")
        except ValueError as e:
            print(f"Error: {e}")
        except ZeroDivisionError:
            print("Error: Cannot divide by zero")
        except Exception as e:  # pylint: disable=broad-exception-caught
            # Catch all to prevent REPL from crashing
            print(f"Error: {e}")

    def execute_command(self, command: str, args: list) -> float:
        """Execute a calculator command.

        Args:
            command: Command name (add, subtract, multiply, divide)
            args: List of string arguments

        Returns:
            Result of the calculation

        Raises:
            ValueError: If command is invalid or args are wrong
        """
        # Normalize command to lowercase
        command = command.lower()

        # Validate we have exactly 2 arguments
        if len(args) != 2:
            raise ValueError(f"Command '{command}' requires exactly 2 numbers")

        # Convert arguments to numbers
        try:
            num1 = float(args[0])
            num2 = float(args[1])
        except ValueError as exc:
            raise ValueError(f"Invalid numbers: {args}") from exc

        # Execute the operation
        if command == 'add':
            result = num1 + num2
        elif command == 'subtract':
            result = num1 - num2
        elif command == 'multiply':
            result = num1 * num2
        elif command == 'divide':
            if num2 == 0:
                raise ZeroDivisionError()
            result = num1 / num2
        else:
            raise ValueError(f"Unknown command: {command}")

        # Check max value limit
        if abs(result) > self.config.max_value:
            raise ValueError(
                f"Result exceeds maximum value: {self.config.max_value}"
            )

        # Format with configured precision
        return round(result, self.config.precision)


def main():
    """Entry point for the REPL."""
    repl = CalculatorREPL()
    repl.start()


if __name__ == '__main__':  # pragma: no cover
    main()
